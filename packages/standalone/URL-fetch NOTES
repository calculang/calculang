There are 2 levels of support for URLs

1. you can point to a URL as entrypoint, it will make fetches and compile
  - this is convenient e.g. can help me to do many tests (not sure if ideal though)
  - already working except for modular

2. you can point to a URL in any cul import
  - this permits overriding a model in the console for demo - but anyplace (emphasizes transparency, portability, modularity, formula reuse)
  - This is harder. The references after pointing to a URL should resolve relative to that URL, which can be scope-dependent and should come from parent scope
  - this lets me REALLY test/demo things

To implement 2 consider cheap/shallow integration. Cheap=just a new pass (new fs0) should work.
Possibly DX by (entrypoint or fs) => resolved fs. LATER consider if really needs to be new pass


---

If new pass, then I can have sep. pass for URL (fetch) and for local FS (node function). Make the node function for vitest
So, make this first as local testing development? Call it... entrypointToFS.

If I do this with node APIs, then how much of calculang logic needs to be used?

---

ALL IMPLEMENTATIONS can fetch URLs and URLs relative to their scope base URL (recycle fs/resource ref?)

But only using node API => command can I START COMPILING USING LOCAL REFERENCES.

To serve these local models, just host them: then the URL becomes the reference that any compiler can use.

---

Sources can transition Local -> Remote but not easily Remote -> Local - is this OK?

And they can transition Remote -> other Remote

Does the compiler ever need to know?

Do I keep JS import compatability? (necessary for memo and other things)

YES I guess: because I should only fetch/cache *.cul requests


---

Structure for local fetch working. TODO track basenames etc. DONE
NOTE ./a.cul.js in one reference can differ to another (remote reference OR different local folders), so will I need to rename or use scope-specific fs entries? Or keep this as an open issue?

---

pre_fetch is WORKING

TODO integrate it with compile command and API or how exactly?

JUST WIRING TODO and more complete end-end testing
